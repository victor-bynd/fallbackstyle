/**
 * CSS Exporter Utility
 * Generates production-ready CSS from typography settings
 */

/**
 * Generate @font-face declarations
 */
function generateFontFaceRules(fonts, includeFontFace, fontScales) {
    if (!includeFontFace) return '';

    const rules = [];

    fonts.forEach(font => {
        if (font.fontUrl && font.fileName) {
            const fontFamily = font.fileName.replace(/\.[^/.]+$/, ''); // Remove extension
            const isFallback = font.type === 'fallback';

            // Calculate font-size-adjust value (scale percentage as decimal)
            const sizeAdjust = isFallback ? (fontScales.fallback / 100) : 1;

            rules.push(`@font-face {
  font-family: '${fontFamily}';
  src: url('${font.fontUrl}') format('truetype');
  font-display: swap;
  size-adjust: ${Math.round(sizeAdjust * 100)}%;
}`);
        }
    });

    return rules.length > 0 ? `/* Font Face Declarations */\n${rules.join('\n\n')}\n\n` : '';
}

/**
 * Generate header styles
 */
function generateHeaderStyles(headerStyles, baseFontSize) {
    const rules = [];

    Object.entries(headerStyles).forEach(([tag, style]) => {
        const fontSize = Math.round(style.scale * baseFontSize);
        rules.push(`${tag} {
  font-size: ${fontSize}px;
  line-height: ${style.lineHeight};
}`);
    });

    return `/* Header Styles */\n${rules.join('\n\n')}\n\n`;
}

/**
 * Generate language-specific overrides
 */
function generateLanguageOverrides(context, languages) {
    const { fallbackFontOverrides, fonts } = context;

    if (Object.keys(fallbackFontOverrides).length === 0) return '';

    const rules = [];

    Object.entries(fallbackFontOverrides).forEach(([langId, fontId]) => {
        const language = languages.find(l => l.id === langId);
        if (!language) return;

        const font = fonts.find(f => f.id === fontId);
        if (!font) return;

        const fontFamily = font.fileName?.replace(/\.[^/.]+$/, '') || 'sans-serif';
        const lineHeightValue = font.lineHeight || context.lineHeight;

        rules.push(`[lang="${language.code}"] {
  font-family: '${fontFamily}', sans-serif;
  line-height: ${lineHeightValue};
}`);
    });

    return rules.length > 0 ? `/* Language-Specific Overrides */\n${rules.join('\n\n')}\n` : '';
}

/**
 * Main CSS generation function
 */
export function generateCSS(context, languages = [], options = {}) {
    const {
        includeFontFace = false,
        includeComments = true,
        prettyPrint = true
    } = options;

    let css = '';

    // Add header comment
    if (includeComments) {
        css += `/* Generated by Localize Type */\n/* ${new Date().toISOString()} */\n\n`;
    }

    // Generate sections
    css += generateFontFaceRules(context.fonts, includeFontFace, context.fontScales);
    css += generateHeaderStyles(context.headerStyles, context.baseFontSize);
    css += generateLanguageOverrides(context, languages);

    // Minify if needed
    if (!prettyPrint) {
        css = css.replace(/\s+/g, ' ').replace(/\n/g, '').trim();
    }

    return css;
}
